# 2.8 Actor模型

## 2.8.1 基础介绍

Actor模型是一种并发编程模型，它将并发执行的任务封装为独立的实体（Actor），每个Actor都有自己的状态和行为。Actor之间通过消息传递进行通信，而不是直接共享内存。

[due](https://github.com/dobyte/due)框架提供的Actor模型与众多开源项目提供的Actor模型还有所不同。[due](https://github.com/dobyte/due)的Actor模型不仅提供了基于查找（[ctx.Actor](https://github.com/dobyte/due/blob/main/cluster/node/context.go)）的传统手动消息分发功能，还提供了通过[ctx.BindActor](https://github.com/dobyte/due/blob/main/cluster/node/context.go)方法绑定用户（UID）与Actor，从而实现Actor消息的自动分发功能。

## 2.8.2 何时使用

避免数据竞争的高并发场景。例如：房间类型游戏等。

## 2.8.3 示例代码

以下完整示例详见：[actor-example](https://github.com/dobyte/due-docs/tree/master/examples/actor-example)

1. 核心逻辑

文件位置：[actor-example/app/logic/core.go](https://github.com/dobyte/due-docs/blob/master/examples/actor-example/app/logic/core.go)

```go
package logic

import (
	"actor-example/app/base"
	"actor-example/app/middleware"
	"actor-example/app/route"
	"hash/fnv"

	"github.com/dobyte/due/v2/cluster/node"
	"github.com/dobyte/due/v2/codes"
	"github.com/dobyte/due/v2/errors"
	"github.com/dobyte/due/v2/log"
	"github.com/dobyte/due/v2/utils/xconv"
)

const defaultPassword = "123456"

const roomActor = "room"

type core struct {
	proxy *node.Proxy
	rooms map[int64]*room
}

func NewCore(proxy *node.Proxy) *core {
	return &core{proxy: proxy}
}

func (c *core) Init() {
	c.proxy.Router().Group(func(group *node.RouterGroup) {
		// 登录
		group.AddRouteHandler(route.Login, c.login)
		// 设置认证中间件
		group.Middleware(middleware.Auth)
		// 创建
		group.AddRouteHandler(route.Create, c.create, node.AuthorizedRoute)
		// 加入
		group.AddRouteHandler(route.Join, c.join, node.AuthorizedRoute)
		// 游戏
		group.AddRouteHandler(route.Play, c.play, node.StatefulRoute)
	})
}

// 登录
func (c *core) login(ctx node.Context) {
	ctx.Task(func(ctx node.Context) {
		req := &loginReq{}
		res := &loginRes{}
		ctx.Defer(func() {
			if err := ctx.Response(res); err != nil {
				log.Errorf("response message failed: %v", err)
			}
		})

		if err := ctx.Parse(req); err != nil {
			log.Errorf("parse request message failed: %v", err)
			res.Code = codes.InternalError.Code()
			return
		}

		// 执行登录操作
		uid, err := c.doLogin(req)
		if err != nil {
			res.Code = codes.Convert(err).Code()
			return
		}

		// 绑定网关
		if err = ctx.BindGate(uid); err != nil {
			log.Errorf("bind gate failed: %v", err)
			res.Code = codes.InternalError.Code()
			return
		}

		res.Code = codes.OK.Code()
	})
}

// 执行登录操作
func (c *core) doLogin(req *loginReq) (int64, error) {
	if req.Password != defaultPassword {
		return 0, errors.NewError(codes.InvalidArgument)
	}

	fnv := fnv.New64a()
	fnv.Write([]byte(req.Account))
	uid := fnv.Sum64()

	return int64(uid), nil
}

// 创建
func (c *core) create(ctx node.Context) {
	req := &createReq{}
	res := &createRes{}
	ctx.Defer(func() {
		if err := ctx.Response(res); err != nil {
			log.Errorf("response message failed: %v", err)
		}
	})

	if err := ctx.Parse(req); err != nil {
		log.Errorf("parse request message failed: %v", err)
		res.Code = codes.InternalError.Code()
		return
	}

	// 执行创建操作
	r, err := c.doCreate(ctx, req)
	if err != nil {
		res.Code = codes.Convert(err).Code()
		return
	}

	res.Code = codes.OK.Code()
	res.Data = &createResData{RoomID: r.id}
}

// 执行创建操作
func (c *core) doCreate(ctx node.Context, req *createReq) (*room, error) {
	var (
		err   error
		actor *node.Actor
	)

	r := newRoom(int64(len(c.rooms)+1), req.Name, ctx.UID())

	if actor, err = c.proxy.Spawn(newRoomProcessor, node.WithActorID(xconv.String(r.id)), node.WithActorArgs(r), node.WithActorKind(roomActor)); err != nil {
		log.Errorf("spawn actor faile: %v", err)
		return nil, errors.NewError(err, codes.InternalError)
	}

	defer func() {
		if err != nil {
			actor.Destroy()
		}
	}()

	if err = ctx.BindActor(actor.Kind(), actor.ID()); err != nil {
		log.Errorf("bind actor failed: %v", err)
		return nil, errors.NewError(err, codes.InternalError)
	}

	defer func() {
		if err != nil {
			ctx.UnbindActor(actor.Kind())
		}
	}()

	if err = ctx.BindNode(); err != nil {
		log.Errorf("bind node failed: %v", err)
		return nil, errors.NewError(err, codes.InternalError)
	}

	c.rooms[r.id] = r

	return r, nil
}

// 加入
// 多节点场景需要借助共享存储（如Redis）来存储房间信息，以便能够通过房间ID找到对应房间所在的节点，并将消息转发至对应节点服进行处理，此处细节不再赘述。
func (c *core) join(ctx node.Context) {
	req := &joinReq{}
	res := &joinRes{}
	ctx.Defer(func() {
		if err := ctx.Response(res); err != nil {
			log.Errorf("response message failed: %v", err)
		}
	})

	if err := ctx.Parse(req); err != nil {
		log.Errorf("parse request message failed: %v", err)
		res.Code = codes.InternalError.Code()
		return
	}

	actor, ok := ctx.Actor(roomActor, xconv.String(req.RoomID))
	if !ok {
		res.Code = codes.NotFound.Code()
		return
	}

	actor.Next(ctx)
}

// 游戏
func (c *core) play(ctx node.Context) {
	res := &base.Res{}
	ctx.Defer(func() {
		if err := ctx.Response(res); err != nil {
			log.Errorf("response message failed: %v", err)
		}
	})

	if err := ctx.Next(); err != nil {
		log.Errorf("request next failed: uid = %v route = %v err = %v", ctx.UID(), ctx.Route(), err)
		res.Code = codes.IllegalRequest.Code()
	}
}
```

2. 房间类

文件位置：[actor-example/app/logic/room.go](https://github.com/dobyte/due-docs/blob/master/examples/actor-example/app/logic/room.go)

```go
package logic

import (
	"github.com/dobyte/due/v2/cluster/node"
	"github.com/dobyte/due/v2/codes"
	"github.com/dobyte/due/v2/errors"
	"github.com/dobyte/due/v2/log"
	"github.com/dobyte/due/v2/utils/xconv"
)

type room struct {
	id      int64
	name    string
	creator int64
	members map[int64]struct{}
}

func newRoom(id int64, name string, creator int64) *room {
	r := &room{}
	r.id = id
	r.name = name
	r.creator = creator
	r.members = make(map[int64]struct{})
	r.members[r.creator] = struct{}{}

	return r
}

// 加入
func (r *room) doJoin(ctx node.Context) (err error) {
	uid := ctx.UID()

	if _, ok := r.members[uid]; ok {
		return errors.NewError(codes.IllegalRequest)
	}

	if err = ctx.BindNode(); err != nil {
		return errors.NewError(codes.InternalError, err)
	}

	defer func() {
		if err != nil {
			ctx.UnbindNode()
		}
	}()

	if err = ctx.BindActor(roomActor, xconv.String(r.id)); err != nil {
		return errors.NewError(codes.InternalError, err)
	}

	r.members[uid] = struct{}{}

	return nil
}

// 游戏
func (r *room) doPlay(ctx node.Context, req *playReq) (err error) {
	uid := ctx.UID()

	if _, ok := r.members[uid]; !ok {
		return errors.NewError(codes.IllegalRequest)
	}

	if req.Action != "move" {
		return errors.NewError(codes.InvalidArgument)
	}

	log.Infof("play, uid: %v, action: %v", uid, req.Action)

	return nil
}
```

3. 房间actor消息处理器类

文件位置：[actor-example/app/logic/room_processor.go](https://github.com/dobyte/due-docs/blob/master/examples/actor-example/app/logic/room_processor.go)

```go
package logic

import (
	"actor-example/app/route"

	"github.com/dobyte/due/v2/cluster/node"
	"github.com/dobyte/due/v2/codes"
	"github.com/dobyte/due/v2/log"
)

type roomProcessor struct {
	node.BaseProcessor
	actor *node.Actor
	room  *room
}

func newRoomProcessor(actor *node.Actor, args ...any) node.Processor {
	return &roomProcessor{
		actor: actor,
		room:  args[0].(*room),
	}
}

// Init 初始化处理器
func (p *roomProcessor) Init() {
	// 加入
	p.actor.AddRouteHandler(route.Join, p.join)
	// 游戏
	p.actor.AddRouteHandler(route.Play, p.play)
}

// 加入
func (p *roomProcessor) join(ctx node.Context) {
	res := &joinRes{}
	ctx.Defer(func() {
		if err := ctx.Response(res); err != nil {
			log.Errorf("response message failed: %v", err)
		}
	})

	// 执行加入操作
	if err := p.room.doJoin(ctx); err != nil {
		res.Code = codes.Convert(err).Code()
		return
	}

	res.Code = codes.OK.Code()
}

// 游戏
func (p *roomProcessor) play(ctx node.Context) {
	req := &playReq{}
	res := &playRes{}
	ctx.Defer(func() {
		if err := ctx.Response(res); err != nil {
			log.Errorf("response message failed: %v", err)
		}
	})

	if err := ctx.Parse(req); err != nil {
		log.Errorf("parse request message failed: %v", err)
		res.Code = codes.InternalError.Code()
		return
	}

	// 执行游戏操作
	if err := p.room.doPlay(ctx, req); err != nil {
		res.Code = codes.Convert(err).Code()
		return
	}

	res.Code = codes.OK.Code()
}
```